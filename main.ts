/*
TODO:
- Being able to generate new players.
- Create the main game loop.
- Implement events
- Implement players
*/

import { Player } from "./Player.ts";
import { StatusEnum, StatusList } from "./Status.ts";
import { Event, EventList, select_random_player } from "./Event.ts";
import { pick_random_item } from "./Inventory.ts";

function printSync(input: string | Uint8Array, to = Deno.stdout) {
    let bytesWritten = 0
    const bytes = typeof input === 'string' ? new TextEncoder().encode(input) : input
    while (bytesWritten < bytes.length) {
        bytesWritten += to.writeSync(bytes.subarray(bytesWritten))
    }
}

/**
 * 
 * SETUP
 * 
 */

const player_list: Array<Player> = [];
const getAlive = () => player_list.filter((player) => player.status[0].state == StatusEnum.ALIVE);
const getDead = () => player_list.filter((player) => player.status[0].state == StatusEnum.DEAD);

let days = 1;

/**
 * Insert your players here
 */
const player_count = 20;

for(let i = 0; i < player_count; i++){
	player_list.push({
		name:              `${i}`,
		kills:             0,
		status:            [StatusList[0]()],
		interacted:        false,

		inventory:         [],

		days_since_hunger: 0,
		days_since_thirst: 0,
	});
}

// sort event_list by chance, low to high
EventList.sort((a, b) => a.chance - b.chance);

/**
 * 
 * MAIN LOOP
 * 
 * No player can interact more than once per day.
 * All players must interact with each other per day.
 * No dead players can play.
 * 
 */

while(getAlive().length > 1){
	const day_log_message = `------------Day ${days}------------`
	console.log(day_log_message);
	let interacted = 0;
	
	player_list.sort(() => Math.random() - 0.5);
	
	// Pahse 1: update the statuses. Only after day 1.
	if(days > 1){
		player_list.forEach((player) => {
			let i = 0;
			while (i < player.status.length) {
				const status = player.status[i];
				status.payload(status, player);
				i++;
			}
		});
	}

	console.log('-'.repeat(day_log_message.length));

	const alive_ones = getAlive().length;

	// Phase 2: pickup items
	getAlive().forEach((player) => {
		const Outcomes = [
			[3 , .01],
			[-1, .03], // Steal
			[2 , .05],
			[1 , .15],
			[0 , 1.0],
		]

		let amount = 0;
		let new_items = [];

		for(let i = 0; i < Outcomes.length; i++){
			const lucky_one = Outcomes[i];
			if(Math.random() < lucky_one[1]){
				amount = lucky_one[0];
				break;
			}
		}

		if(amount < 0 && player_list.length >= 2){
			let player2 = select_random_player(player_list);

			while(player2 == player) {
				player2 = select_random_player(player_list);
			}

			if (player2.inventory.length > 0) {
				const stolenItemIndex = Math.floor(Math.random() * player2.inventory.length);
				const stolenItem = player2.inventory.splice(stolenItemIndex, 1)[0];
				player.inventory.push(stolenItem);
				if(player2.status[0].state == StatusEnum.DEAD)
					console.log(`${player.name} stole ${stolenItem.name} from the corpse of ${player2.name}`);
				else
					console.log(`${player.name} stole ${stolenItem.name} from ${player2.name}`);
			}
		} else {
			player.inventory = player.inventory.concat(pick_random_item(amount));

			if (amount > 0) {
				// Generate by Copilot, I don't actually have that much idea of what it does.
				const itemNames = player.inventory.slice(-amount).map(item => item.name).join(', ');
				console.log(`${player.name} got these items: ${itemNames}`);
			}
		}

	})
	
	console.log('-'.repeat(day_log_message.length));

	// Phase 3: select an event
	// Phase 4: make players/groups interact
	while(interacted < alive_ones){
		const event = Event.pick_event(EventList) as Event;

		if(event.play_affected > alive_ones - interacted)
			continue;

		const [log, interactions] = event.payload(player_list, [], interacted, days);

		interacted += interactions;

		console.log(log);
	}
	// Phase 5: repeat
	player_list.forEach((player) => {
		if(player.status[0].state == StatusEnum.ALIVE)
			player.interacted = false;
	});

	console.log(`************ + Dead + ************`);
	getDead().forEach((player) => {
		if(player.status[0].days_since_effect == 0)
			printSync(player.name + " ");
	});

	printSync(`(${getDead().filter((player) => player.status[0].days_since_effect == 0).length}) \n`);
	days += 1;

	await new Promise<void>((resolve) => {
		Deno.stdin.read(new Uint8Array(1)).then(() => resolve());
	})
}

/**
 * 
 * END
 * 
 */

console.log(`------------Day ${days}------------`);

if(getAlive().length == 0){
	console.log("Nobody wins :(");
} else {
	const lucky_one = getAlive()[0];
	let statusMessage = '';
	if (lucky_one.status.some(status => status.state == StatusEnum.INJURED)) {
		statusMessage = ' (while injured!)';
	} else if (lucky_one.status.some(status => status.state == StatusEnum.POISONED)) {
		statusMessage = ' (while poisoned!)';
	}
	console.log(`Player ${lucky_one.name} wins ${statusMessage}! (${lucky_one.kills})`);

	// Code generated by Copilot. I don't actually know what these do.
	const mostKills = player_list.reduce((max, player) => player.kills > max.kills ? player : max, player_list[0]);
	console.log(`Player with most kills: ${mostKills.name} (${mostKills.kills})`);

	const mostHoarder = player_list.reduce((max, player) => player.inventory.length > max.inventory.length ? player : max, player_list[0]);
	const itemNames = mostHoarder.inventory.map(item => item.name).join(', ');
	console.log(`The most hoarder: ${mostHoarder.name} (${mostHoarder.inventory.length})${itemNames ? ` Items: ${itemNames}` : ''}`);
}
